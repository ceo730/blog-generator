<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>정보성 블로그 원고 제작기</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --primary: #2d5a27;
  --primary-light: #e8f5e3;
  --accent-red: #ba0000;
  --highlight-bg: #fff8b2;
  --bg: #f5f5f5;
  --card: #ffffff;
  --border: #e0e0e0;
  --text: #333333;
  --text-light: #777777;
  --shadow: 0 2px 8px rgba(0,0,0,0.08);
}
body {
  font-family: 'Nanum Myeongjo', 'Malgun Gothic', serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
  min-height: 100vh;
}
/* Toolbar */
.toolbar {
  background: var(--primary);
  color: #fff;
  padding: 12px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  position: sticky;
  top: 0;
  z-index: 100;
}
.toolbar h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.5px; }
.toolbar-actions { display: flex; gap: 8px; }
.toolbar-btn {
  background: rgba(255,255,255,0.15);
  border: 1px solid rgba(255,255,255,0.3);
  color: #fff;
  padding: 6px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-family: inherit;
  transition: background 0.2s;
}
.toolbar-btn:hover { background: rgba(255,255,255,0.25); }

/* Main Layout */
.main-container {
  display: flex;
  height: calc(100vh - 50px);
  overflow: hidden;
}

/* Input Panel */
.input-panel {
  width: 380px;
  min-width: 380px;
  background: var(--card);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.input-panel h2 {
  font-size: 15px;
  color: var(--primary);
  border-bottom: 2px solid var(--primary);
  padding-bottom: 8px;
  margin-bottom: 4px;
}
.form-group { display: flex; flex-direction: column; gap: 6px; }
.form-group label {
  font-size: 13px;
  font-weight: 700;
  color: var(--text);
}
.form-group label .optional {
  font-weight: 400;
  color: var(--text-light);
  font-size: 11px;
}
.form-group input,
.form-group textarea,
.form-group select {
  font-family: 'Malgun Gothic', sans-serif;
  font-size: 14px;
  padding: 10px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  outline: none;
  transition: border-color 0.2s;
}
.form-group input:focus,
.form-group textarea:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px var(--primary-light);
}
.form-group textarea { resize: vertical; min-height: 60px; }
.generate-btn {
  background: var(--primary);
  color: #fff;
  border: none;
  padding: 14px;
  border-radius: 10px;
  font-size: 16px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
  margin-top: 8px;
}
.generate-btn:hover { background: #1e4a1a; }
.generate-btn:active { transform: scale(0.98); }
.generate-btn:disabled {
  background: #aaa;
  cursor: not-allowed;
  transform: none;
}
.progress-area {
  background: #f8f9fa;
  border-radius: 8px;
  padding: 12px;
  font-size: 13px;
  color: var(--text-light);
  display: none;
}
.progress-area.active { display: block; }
.progress-area .spinner {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--border);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  vertical-align: middle;
  margin-right: 6px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Preview Panel */
.preview-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.tab-bar {
  display: flex;
  background: var(--card);
  border-bottom: 1px solid var(--border);
  padding: 0 16px;
}
.tab-btn {
  padding: 12px 20px;
  border: none;
  background: none;
  font-size: 14px;
  font-family: inherit;
  color: var(--text-light);
  cursor: pointer;
  border-bottom: 3px solid transparent;
  transition: all 0.2s;
}
.tab-btn.active {
  color: var(--primary);
  border-bottom-color: var(--primary);
  font-weight: 700;
}
.tab-content {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
  display: none;
}
.tab-content.active { display: block; }

/* Blog Preview Styles */
.blog-preview {
  max-width: 680px;
  margin: 0 auto;
  background: #fff;
  padding: 32px;
  border-radius: 12px;
  box-shadow: var(--shadow);
  font-family: 'Nanum Myeongjo', serif;
  font-size: 16px;
  line-height: 1.85;
  color: #000;
}
.blog-preview .empty-state {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-light);
}
.blog-preview .empty-state p { font-size: 15px; margin-top: 12px; }
.blog-preview .hook {
  font-size: 17px;
  line-height: 1.9;
  margin-bottom: 28px;
}
.blog-preview .context {
  font-size: 15px;
  color: #555;
  margin-bottom: 28px;
  padding: 16px 20px;
  background: #fafafa;
  border-radius: 8px;
}
/* Quote boxes */
.blog-preview .quote-box {
  border: 1px solid #e8e8e8;
  border-radius: 8px;
  padding: 20px 24px;
  margin: 24px 0;
  background: #fafbfc;
}
.blog-preview .quote-box.corner {
  border-left: 4px solid var(--primary);
  background: var(--primary-light);
}
.blog-preview .quote-box.underline {
  border: none;
  border-bottom: 3px solid var(--primary);
  background: transparent;
  padding: 12px 0 8px 0;
  margin: 32px 0 16px 0;
}
.blog-preview .quote-box.underline h3 {
  font-size: 19px;
  font-weight: 800;
  color: #000;
}
.blog-preview .toc-title {
  font-size: 15px;
  font-weight: 700;
  color: var(--primary);
  margin-bottom: 10px;
}
.blog-preview .toc-list {
  list-style: none;
  padding: 0;
}
.blog-preview .toc-list li {
  padding: 6px 0;
  font-size: 15px;
  border-bottom: 1px dashed #e0e0e0;
}
.blog-preview .toc-list li:last-child { border-bottom: none; }
.blog-preview .section { margin-bottom: 36px; }
.blog-preview .section p { margin-bottom: 14px; }
.blog-preview .red-bold { color: var(--accent-red); font-weight: 700; }
.blog-preview .yellow-hl {
  background: var(--highlight-bg);
  font-weight: 700;
  padding: 1px 4px;
}
.blog-preview .key-points {
  background: #f7f8f9;
  border-radius: 8px;
  padding: 16px 20px;
  margin: 16px 0;
}
.blog-preview .key-points li {
  margin-bottom: 6px;
  list-style: none;
  position: relative;
  padding-left: 24px;
}
.blog-preview .key-points li::before {
  content: '\2713';
  position: absolute;
  left: 0;
  color: var(--primary);
  font-weight: 700;
}
.blog-preview .data-box {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
  margin: 16px 0;
}
.blog-preview .data-box table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}
.blog-preview .data-box th {
  background: var(--primary);
  color: #fff;
  padding: 10px 14px;
  text-align: left;
  font-weight: 700;
}
.blog-preview .data-box td {
  padding: 10px 14px;
  border-bottom: 1px solid #eee;
}
.blog-preview .data-box tr:last-child td { border-bottom: none; }
.blog-preview .data-box tr:nth-child(even) td { background: #f9f9f9; }
.blog-preview .img-placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f0f0f0;
  border: 2px dashed #ccc;
  border-radius: 8px;
  padding: 16px;
  margin: 16px 0;
  color: var(--text-light);
  font-size: 14px;
  min-height: 60px;
}
.blog-preview .img-placeholder img {
  max-width: 100%;
  border-radius: 6px;
}
.blog-preview .conclusion {
  background: linear-gradient(135deg, var(--primary-light) 0%, #f0faf0 100%);
  border-radius: 12px;
  padding: 24px;
  margin-top: 32px;
}
.blog-preview .conclusion h3 {
  color: var(--primary);
  font-size: 18px;
  margin-bottom: 12px;
}

/* HTML Code Tab */
#tab-html {
  background: #1e1e2e;
}
.code-area {
  position: relative;
}
.code-area pre {
  background: #1e1e2e;
  color: #cdd6f4;
  padding: 20px;
  border-radius: 8px;
  overflow-x: auto;
  font-family: 'Consolas', 'Courier New', monospace;
  font-size: 13px;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-all;
}
.copy-code-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: #fff;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  font-family: 'Malgun Gothic', sans-serif;
}
.copy-code-btn:hover { background: rgba(255,255,255,0.2); }

/* Images Tab */
.images-grid {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.image-card {
  background: var(--card);
  border-radius: 10px;
  padding: 16px;
  box-shadow: var(--shadow);
}
.image-card .image-label {
  font-size: 13px;
  font-weight: 700;
  color: var(--primary);
  margin-bottom: 10px;
}
.image-card img {
  max-width: 100%;
  border-radius: 6px;
  border: 1px solid var(--border);
}
.image-card .image-actions {
  margin-top: 8px;
  display: flex;
  gap: 8px;
}
.image-card .image-actions button {
  font-family: 'Malgun Gothic', sans-serif;
  font-size: 12px;
  padding: 5px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: #fff;
  cursor: pointer;
  transition: background 0.2s;
}
.image-card .image-actions button:hover { background: #f0f0f0; }
.download-all-btn {
  background: var(--primary);
  color: #fff;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  margin-bottom: 16px;
}
.download-all-btn:hover { background: #1e4a1a; }

/* Section Copy Mode */
.section-copy-panel {
  background: var(--card);
  border-radius: 10px;
  box-shadow: var(--shadow);
  padding: 20px;
}
.section-copy-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  border-bottom: 1px solid #f0f0f0;
  gap: 12px;
}
.section-copy-item:last-child { border-bottom: none; }
.section-copy-item .label { font-size: 14px; flex: 1; }
.section-copy-item .type-badge {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 10px;
  background: var(--primary-light);
  color: var(--primary);
  font-weight: 700;
}
.section-copy-item button {
  font-family: 'Malgun Gothic', sans-serif;
  font-size: 12px;
  padding: 5px 14px;
  border: 1px solid var(--primary);
  border-radius: 6px;
  background: #fff;
  color: var(--primary);
  cursor: pointer;
  font-weight: 700;
}
.section-copy-item button:hover { background: var(--primary-light); }
.section-copy-item button.copied {
  background: var(--primary);
  color: #fff;
}

/* Settings Modal */
.modal-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 200;
}
.modal-overlay.active { display: flex; }
.modal-box {
  background: #fff;
  border-radius: 12px;
  padding: 28px;
  width: 420px;
  max-width: 90vw;
  box-shadow: 0 8px 30px rgba(0,0,0,0.2);
}
.modal-box h2 {
  font-size: 17px;
  margin-bottom: 16px;
  color: var(--primary);
}
.modal-box .form-group { margin-bottom: 14px; }
.modal-box .btn-row { display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px; }
.modal-box .btn-save {
  background: var(--primary);
  color: #fff;
  border: none;
  padding: 8px 20px;
  border-radius: 6px;
  font-family: inherit;
  font-size: 14px;
  cursor: pointer;
}
.modal-box .btn-cancel {
  background: #eee;
  border: none;
  padding: 8px 20px;
  border-radius: 6px;
  font-family: inherit;
  font-size: 14px;
  cursor: pointer;
}
.api-key-status {
  font-size: 12px;
  margin-top: 4px;
}
.api-key-status.set { color: var(--primary); }
.api-key-status.unset { color: var(--accent-red); }

/* Toast */
.toast {
  position: fixed;
  bottom: 24px;
  right: 24px;
  background: #333;
  color: #fff;
  padding: 12px 20px;
  border-radius: 8px;
  font-size: 14px;
  z-index: 300;
  opacity: 0;
  transform: translateY(10px);
  transition: all 0.3s;
  pointer-events: none;
}
.toast.show {
  opacity: 1;
  transform: translateY(0);
}

/* Responsive */
@media (max-width: 900px) {
  .main-container { flex-direction: column; height: auto; }
  .input-panel { width: 100%; min-width: auto; border-right: none; border-bottom: 1px solid var(--border); }
  .preview-panel { height: 70vh; }
}
</style>
</head>
<body>

<!-- Toolbar -->
<div class="toolbar">
  <h1>&#128221; 정보성 블로그 원고 제작기</h1>
  <div class="toolbar-actions">
    <button class="toolbar-btn" onclick="copyRichText()" title="서식 포함 복사">텍스트 복사</button>
    <button class="toolbar-btn" onclick="downloadAllImages()" title="이미지 ZIP 다운로드">이미지 다운로드</button>
    <button class="toolbar-btn" onclick="openSettings()">API 설정</button>
  </div>
</div>

<!-- Main -->
<div class="main-container">
  <!-- Input Panel -->
  <div class="input-panel">
    <h2>원고 설정</h2>

    <div class="form-group">
      <label>글 주제 / 키워드 <span class="optional">(필수)</span></label>
      <input type="text" id="topicInput" placeholder="예: 학생부 세특 작성법, 수학 교과 세특">
    </div>

    <div class="form-group">
      <label>세부 주제 <span class="optional">(선택)</span></label>
      <textarea id="subtopicInput" rows="2" placeholder="예: 수학 세특에서 자주 하는 실수 3가지와 해결법"></textarea>
    </div>

    <div class="form-group">
      <label>대상 독자 <span class="optional">(선택)</span></label>
      <input type="text" id="audienceInput" placeholder="예: 고등학생 학부모, 입시 준비생">
    </div>

    <div class="form-group">
      <label>글 길이</label>
      <select id="lengthSelect">
        <option value="medium" selected>보통 (2,000~2,400자)</option>
        <option value="short">짧게 (1,200~1,600자)</option>
        <option value="long">길게 (2,800~3,400자)</option>
      </select>
    </div>

    <div class="form-group">
      <label>API Key 상태</label>
      <div id="apiKeyStatus" class="api-key-status unset">미설정 - API 설정을 눌러주세요</div>
    </div>

    <button class="generate-btn" id="generateBtn" onclick="generateArticle()">
      원고 생성하기
    </button>

    <div class="progress-area" id="progressArea">
      <span class="spinner"></span>
      <span id="progressText">Claude API에 연결 중...</span>
    </div>
  </div>

  <!-- Preview Panel -->
  <div class="preview-panel">
    <div class="tab-bar">
      <button class="tab-btn active" onclick="switchTab('blog')">블로그 뷰</button>
      <button class="tab-btn" onclick="switchTab('html')">HTML 코드</button>
      <button class="tab-btn" onclick="switchTab('images')">이미지</button>
      <button class="tab-btn" onclick="switchTab('sections')">섹션별 복사</button>
    </div>

    <div class="tab-content active" id="tab-blog">
      <div class="blog-preview" id="blogPreview">
        <div class="empty-state">
          <div style="font-size:48px; margin-bottom:8px;">&#128196;</div>
          <p>좌측에서 주제를 입력하고<br>"원고 생성하기"를 눌러주세요</p>
        </div>
      </div>
    </div>

    <div class="tab-content" id="tab-html">
      <div class="code-area">
        <button class="copy-code-btn" onclick="copyHtmlCode()">복사</button>
        <pre id="htmlCode">원고를 생성하면 HTML 코드가 여기에 표시됩니다.</pre>
      </div>
    </div>

    <div class="tab-content" id="tab-images">
      <div id="imagesContainer">
        <div class="empty-state" style="text-align:center; padding:60px 20px; color:var(--text-light);">
          <div style="font-size:48px; margin-bottom:8px;">&#128247;</div>
          <p>원고를 생성하면 이미지가 자동으로 생성됩니다</p>
        </div>
      </div>
    </div>

    <div class="tab-content" id="tab-sections">
      <div id="sectionsContainer">
        <div class="empty-state" style="text-align:center; padding:60px 20px; color:var(--text-light);">
          <div style="font-size:48px; margin-bottom:8px;">&#128203;</div>
          <p>원고를 생성하면 섹션별 복사 기능을 사용할 수 있습니다</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal-box">
    <h2>API 설정</h2>
    <div class="form-group">
      <label>Claude API Key</label>
      <input type="password" id="apiKeyInput" placeholder="sk-ant-api03-...">
      <div style="font-size:11px; color:var(--text-light); margin-top:4px;">
        API Key는 브라우저 localStorage에만 저장됩니다.
      </div>
    </div>
    <div class="btn-row">
      <button class="btn-cancel" onclick="closeSettings()">취소</button>
      <button class="btn-save" onclick="saveSettings()">저장</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ─────────────────────────────────────────
// STATE
// ─────────────────────────────────────────
let generatedData = null;   // parsed JSON from Claude
let generatedImages = [];   // {label, blob, dataUrl}
let generatedHtml = '';     // blog HTML
let sectionParts = [];      // for section-by-section copy

// ─────────────────────────────────────────
// SETTINGS
// ─────────────────────────────────────────
function getApiKey() { return localStorage.getItem('claude_api_key') || ''; }
function openSettings() {
  document.getElementById('settingsModal').classList.add('active');
  document.getElementById('apiKeyInput').value = getApiKey();
}
function closeSettings() {
  document.getElementById('settingsModal').classList.remove('active');
}
function saveSettings() {
  const key = document.getElementById('apiKeyInput').value.trim();
  if (key) localStorage.setItem('claude_api_key', key);
  else localStorage.removeItem('claude_api_key');
  updateApiStatus();
  closeSettings();
  showToast('API Key가 저장되었습니다.');
}
function updateApiStatus() {
  const el = document.getElementById('apiKeyStatus');
  if (getApiKey()) {
    el.textContent = 'API Key 설정됨 (' + getApiKey().slice(0,12) + '...)';
    el.className = 'api-key-status set';
  } else {
    el.textContent = '미설정 - API 설정을 눌러주세요';
    el.className = 'api-key-status unset';
  }
}
updateApiStatus();

// ─────────────────────────────────────────
// TABS
// ─────────────────────────────────────────
function switchTab(name) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
  document.getElementById('tab-' + name).classList.add('active');
  const tabNames = ['blog','html','images','sections'];
  document.querySelectorAll('.tab-btn')[tabNames.indexOf(name)].classList.add('active');
}

// ─────────────────────────────────────────
// TOAST
// ─────────────────────────────────────────
function showToast(msg, duration) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(t._timer);
  t._timer = setTimeout(() => t.classList.remove('show'), duration || 2000);
}

// ─────────────────────────────────────────
// SYSTEM PROMPT
// ─────────────────────────────────────────
function buildSystemPrompt() {
  // 매번 다른 구조를 생성하도록 랜덤 파라미터
  const sectionCount = 3 + Math.floor(Math.random() * 2); // 3~4
  const hookStyle = ['질문형', '통계/수치형', '흔한 오해 지적형', '상황 묘사형'][Math.floor(Math.random() * 4)];
  const hasDataPoints = Math.random() > 0.4; // 60% 확률
  const endingStyles = ['~요/~죠', '~다/~입니다', '~거든요/~네요'];
  const ending = endingStyles[Math.floor(Math.random() * 3)];

  return `네이버 블로그에 올릴 순수 정보성 글을 작성하세요.

## 금지사항 (가장 중요! 절대 위반 금지!)
- 글 쓴 사람의 페르소나, 자기소개, 경력, 경험담 절대 불포함
- 다음 단어/표현 절대 사용 금지: "저는", "제가", "나는", "내가", "해봤", "하다 보면", "하다 보니", "알려드릴"
- 주어가 "저/제/나/내"인 문장 절대 금지. "제가" 2글자도 전체 텍스트에 0회여야 함
- 오직 객관적 정보와 실용적 팁만 전달
- 제3자 시점으로만 서술 (정보 전달자/해설자 톤, "~이다", "~한다" 체)

## 문체 규칙
- 문장은 짧게 끊어쓰기 (한 문장 15~30자)
- 문단마다 문장 수를 다르게 (2문장~5문장 섞기)
- 종결어를 다양하게 섞기: "${ending}" 위주로 쓰되, 같은 종결어가 3번 연속 오지 않게
- 강조 표현을 불규칙하게 사용:
  * <b>볼드텍스트</b> → 핵심 키워드 (글 전체에서 4~7회만)
  * <span style="color:#ba0000"><b>빨간볼드</b></span> → 가장 중요한 것 (글 전체에서 2~3회만)
  * <span style="background-color:#fff8b2"><b>노란하이라이트</b></span> → 꼭 기억할 것 (글 전체에서 1~2회만)
- 강조가 없는 문단도 있어야 자연스러움

## 이번 글의 구조 (매번 달라져야 함)
- 도입부 스타일: ${hookStyle}
- 본문 섹션 수: ${sectionCount}개
- 데이터 표 포함: ${hasDataPoints ? '1~2개 섹션에만 포함' : '이번 글에는 미포함'}

## 글자수 가이드 (매우 중요! 반드시 지켜야 함!)
- 사용자가 요청한 글 길이 범위를 정확히 맞추세요
- 글자수 = hook + context + 모든 paragraphs + 모든 keyPoints + conclusion 전체의 순수 텍스트 합계
- HTML 태그(<b>, <span> 등)는 글자수에 미포함
- 섹션이 ${sectionCount}개이므로, 각 섹션의 paragraphs를 충분히 길게 써서 총 글자수를 맞추세요
- 섹션이 적으면 각 섹션을 더 깊이있게, 섹션이 많으면 각 섹션을 간결하게
- 요청 범위의 중간값을 목표로 하세요

## 출력 형식
반드시 아래 JSON만 출력하세요. 코드 펜스, 설명 텍스트 없이 순수 JSON만.

{
  "title": "블로그 글 제목 (25자 이내)",
  "hook": "도입부 (${hookStyle}으로 시작, 4~6문장, 180~250자)",
  "context": "이 글을 읽어야 하는 이유 (2~3문장, 80~120자)",
  "toc": [${Array.from({length: sectionCount}, (_, i) => `"목차${i+1}"`).join(', ')}],
  "sections": [
    {
      "heading": "섹션 제목",
      "paragraphs": ["문단1 (90~140자, 3~5문장)", "문단2 (90~140자)"],
      "keyPoints": ["핵심1", "핵심2"] 또는 null,
      "dataPoints": {"title":"제목", "headers":["항목","설명"], "rows":[["a","b"]]} 또는 null
    }
  ],
  "conclusion": {
    "summary": "요약 (3~4문장, 130~180자)",
    "actionItems": ["행동지침1 (30~50자)", "행동지침2", "행동지침3"],
    "encouragement": "마무리 한마디 (2~3문장, 60~100자)"
  }
}

주의사항:
- sections 수는 toc 수(${sectionCount}개)와 동일
- 각 section의 paragraphs는 2~4개 (섹션마다 다른 수, 예: 첫번째 3개, 두번째 2개, 세번째 4개)
- keyPoints는 있는 섹션(2~3개)과 없는 섹션(null)을 섞기
- dataPoints는 ${hasDataPoints ? '1~2개 섹션에만 포함, rows 최대 4개' : '모든 섹션에서 null'}
- 강조 태그는 위에 명시한 HTML 형식 그대로 사용 (<b>, <span style="color:...">, <span style="background-color:...">)
- 반드시 유효한 JSON으로 응답`;
}

// ─────────────────────────────────────────
// CLAUDE API
// ─────────────────────────────────────────
async function callClaude(topic, subtopic, audience, length) {
  const apiKey = getApiKey();
  if (!apiKey) throw new Error('API Key가 설정되지 않았습니다.');

  const lengthGuide = { short: '1200~1600자', medium: '2000~2400자', long: '2800~3400자' }[length];
  let userMsg = `주제: ${topic}`;
  if (subtopic) userMsg += `\n세부 주제: ${subtopic}`;
  if (audience) userMsg += `\n대상 독자: ${audience}`;
  userMsg += `\n글 길이: ${lengthGuide}`;

  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 8192,
      stream: true,
      system: buildSystemPrompt(),
      messages: [{ role: 'user', content: userMsg }]
    })
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`API 오류 (${response.status}): ${err}`);
  }

  return response.body;
}

async function generateArticle() {
  const topic = document.getElementById('topicInput').value.trim();
  if (!topic) { showToast('주제를 입력해주세요.'); return; }
  if (!getApiKey()) { openSettings(); return; }

  const subtopic = document.getElementById('subtopicInput').value.trim();
  const audience = document.getElementById('audienceInput').value.trim();
  const length = document.getElementById('lengthSelect').value;

  const btn = document.getElementById('generateBtn');
  const progress = document.getElementById('progressArea');
  const progressText = document.getElementById('progressText');

  btn.disabled = true;
  progress.classList.add('active');
  progressText.textContent = 'Claude API에 연결 중...';

  try {
    const stream = await callClaude(topic, subtopic, audience, length);
    progressText.textContent = '글을 생성하고 있습니다...';

    let fullText = '';
    const reader = stream.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6).trim();
          if (data === '[DONE]') continue;
          try {
            const evt = JSON.parse(data);
            if (evt.type === 'content_block_delta' && evt.delta && evt.delta.text) {
              fullText += evt.delta.text;
              const charCount = fullText.length;
              progressText.textContent = `글 생성 중... (${charCount}자)`;
            }
          } catch (e) { /* ignore parse errors for non-JSON lines */ }
        }
      }
    }

    progressText.textContent = '원고를 분석하고 있습니다...';
    generatedData = parseJsonResponse(fullText);

    progressText.textContent = '이미지를 생성하고 있습니다...';
    await generateAllImages(generatedData);

    progressText.textContent = 'HTML을 빌드하고 있습니다...';
    generatedHtml = buildBlogHtml(generatedData);

    renderPreview(generatedData);
    renderHtmlCode(generatedHtml);
    renderImagesTab();
    renderSectionsTab(generatedData);

    progressText.textContent = '완료!';
    showToast('원고가 생성되었습니다!');
    switchTab('blog');

  } catch (err) {
    progressText.textContent = '오류: ' + err.message;
    showToast('오류 발생: ' + err.message, 4000);
    console.error(err);
  } finally {
    btn.disabled = false;
    setTimeout(() => progress.classList.remove('active'), 3000);
  }
}

function parseJsonResponse(text) {
  let jsonStr = text.trim();
  // Remove markdown code fences if present (closed or unclosed)
  jsonStr = jsonStr.replace(/^```(?:json)?\s*/i, '').replace(/```\s*$/, '');
  // Find the JSON object
  const startIdx = jsonStr.indexOf('{');
  if (startIdx === -1) throw new Error('JSON 응답을 찾을 수 없습니다.');
  jsonStr = jsonStr.slice(startIdx);
  // First try direct parse
  try { return JSON.parse(jsonStr); } catch (e) { /* continue to recovery */ }
  // Fix common issues: trailing commas
  jsonStr = jsonStr.replace(/,\s*}/g, '}').replace(/,\s*]/g, ']');
  try { return JSON.parse(jsonStr); } catch (e) { /* continue to truncation recovery */ }
  // If truncated, try to close open brackets
  console.warn('JSON truncated, attempting recovery...');
  let recovered = jsonStr;
  // Remove last incomplete string value
  recovered = recovered.replace(/,?\s*"[^"]*$/, '');
  // Remove trailing incomplete key-value
  recovered = recovered.replace(/,?\s*"[^"]*":\s*$/, '');
  // Count and close open brackets
  let openBraces = 0, openBrackets = 0;
  let inString = false, escape = false;
  for (const ch of recovered) {
    if (escape) { escape = false; continue; }
    if (ch === '\\') { escape = true; continue; }
    if (ch === '"') { inString = !inString; continue; }
    if (inString) continue;
    if (ch === '{') openBraces++;
    if (ch === '}') openBraces--;
    if (ch === '[') openBrackets++;
    if (ch === ']') openBrackets--;
  }
  // Remove trailing comma before closing
  recovered = recovered.replace(/,\s*$/, '');
  for (let i = 0; i < openBrackets; i++) recovered += ']';
  for (let i = 0; i < openBraces; i++) recovered += '}';
  // Final cleanup
  recovered = recovered.replace(/,\s*}/g, '}').replace(/,\s*]/g, ']');
  try { return JSON.parse(recovered); } catch (e2) {
    console.error('JSON recovery failed:', e2.message);
    console.error('Recovered text (last 200):', recovered.slice(-200));
    throw new Error('AI 응답 JSON 파싱 실패. 다시 생성해주세요.');
  }
}

// ─────────────────────────────────────────
// HTML BUILDER (Naver Blog Style)
// ─────────────────────────────────────────
// 프롬프트가 이제 직접 HTML 태그를 출력하므로 processInlineTags는 패스스루
function processInlineTags(text) {
  return text;
}

// 네이버 SE에 붙여넣기 최적화된 클린 HTML 생성
// - <p>, <b>, <span style>, <br>, <table> 등 기본 태그만 사용
// - 컨테이너 div에 복잡한 인라인 스타일 없음
// - 이미지 플레이스홀더 텍스트 없음 (섹션별 복사 탭에서만 안내)
function buildBlogHtml(data) {
  let html = '';

  // Hook (도입부)
  html += `<p>${data.hook}</p>`;
  html += `<p><br></p>`;

  // Context
  if (data.context) {
    html += `<p>${data.context}</p>`;
    html += `<p><br></p>`;
  }

  // TOC (목차) - 간단한 텍스트 리스트
  if (data.toc && data.toc.length) {
    data.toc.forEach((item, i) => {
      html += `<p><b>${i + 1}. ${item}</b></p>`;
    });
    html += `<p><br></p>`;
  }

  // Sections (본문)
  if (data.sections) {
    data.sections.forEach((sec, idx) => {
      // Section heading
      html += `<p><br></p>`;
      html += `<p><b>${sec.heading}</b></p>`;
      html += `<p><br></p>`;

      // Paragraphs
      if (sec.paragraphs) {
        sec.paragraphs.forEach(p => {
          html += `<p>${p}</p>`;
        });
        html += `<p><br></p>`;
      }

      // Key points
      if (sec.keyPoints && sec.keyPoints.length) {
        sec.keyPoints.forEach(kp => {
          html += `<p>\u2713 ${kp}</p>`;
        });
        html += `<p><br></p>`;
      }

      // Data table
      if (sec.dataPoints && sec.dataPoints.headers) {
        if (sec.dataPoints.title) {
          html += `<p><b>${sec.dataPoints.title}</b></p>`;
        }
        html += `<table border="1" cellpadding="8" cellspacing="0" style="border-collapse:collapse;">`;
        html += `<tr>`;
        sec.dataPoints.headers.forEach(h => {
          html += `<th style="background-color:#f5f5f5; padding:8px;">${h}</th>`;
        });
        html += `</tr>`;
        if (sec.dataPoints.rows) {
          sec.dataPoints.rows.forEach(row => {
            html += `<tr>`;
            row.forEach(cell => { html += `<td style="padding:8px;">${cell}</td>`; });
            html += `</tr>`;
          });
        }
        html += `</table>`;
        html += `<p><br></p>`;
      }
    });
  }

  // Conclusion
  if (data.conclusion) {
    html += `<p><br></p>`;
    if (data.conclusion.summary) {
      html += `<p>${data.conclusion.summary}</p>`;
    }
    if (data.conclusion.actionItems && data.conclusion.actionItems.length) {
      html += `<p><br></p>`;
      data.conclusion.actionItems.forEach((ai, i) => {
        html += `<p>${i + 1}. ${ai}</p>`;
      });
    }
    if (data.conclusion.encouragement) {
      html += `<p><br></p>`;
      html += `<p><b>${data.conclusion.encouragement}</b></p>`;
    }
  }

  return html;
}

// ─────────────────────────────────────────
// PREVIEW RENDERING
// ─────────────────────────────────────────
function processInlineTagsPreview(text) {
  // 프롬프트가 직접 HTML을 생성하므로 그대로 반환
  return text;
}

function renderPreview(data) {
  const el = document.getElementById('blogPreview');
  let previewImgIdx = 0;
  let html = '';

  // Card-news representative image
  if (generatedImages[previewImgIdx]) {
    html += `<div style="text-align:center; margin-bottom:20px;">
      <div style="font-size:12px; color:var(--primary); font-weight:700; margin-bottom:6px;">&#9733; 블로그 대표이미지</div>
      <img src="${generatedImages[previewImgIdx].dataUrl}" alt="대표이미지" style="max-width:320px; border-radius:8px; border:1px solid var(--border);">
    </div>`;
  }
  previewImgIdx++;

  // Title image
  if (generatedImages[previewImgIdx]) {
    html += `<div class="img-placeholder"><img src="${generatedImages[previewImgIdx].dataUrl}" alt="타이틀"></div>`;
  }
  previewImgIdx++;

  // Hook
  html += `<div class="hook">${data.hook}</div>`;

  // Context
  if (data.context) {
    html += `<div class="context">${data.context}</div>`;
  }

  // TOC
  if (data.toc && data.toc.length) {
    html += `<div class="quote-box corner">`;
    html += `<div class="toc-title">목차</div><ul class="toc-list">`;
    data.toc.forEach((item, i) => { html += `<li>${i + 1}. ${item}</li>`; });
    html += `</ul></div>`;
  }

  // Sections
  if (data.sections) {
    data.sections.forEach((sec, idx) => {
      html += `<div class="section">`;
      if (generatedImages[previewImgIdx]) {
        html += `<div class="img-placeholder"><img src="${generatedImages[previewImgIdx].dataUrl}" alt="${sec.heading}"></div>`;
      }
      previewImgIdx++;

      html += `<div class="quote-box underline"><h3>${sec.heading}</h3></div>`;

      if (sec.paragraphs) {
        sec.paragraphs.forEach(p => { html += `<p>${p}</p>`; });
      }

      if (sec.keyPoints && sec.keyPoints.length) {
        if (generatedImages[previewImgIdx]) {
          html += `<div class="img-placeholder"><img src="${generatedImages[previewImgIdx].dataUrl}" alt="핵심 포인트"></div>`;
        }
        previewImgIdx++;
        html += `<ul class="key-points">`;
        sec.keyPoints.forEach(kp => { html += `<li>${kp}</li>`; });
        html += `</ul>`;
      }

      if (sec.dataPoints && sec.dataPoints.headers) {
        if (generatedImages[previewImgIdx]) {
          html += `<div class="img-placeholder"><img src="${generatedImages[previewImgIdx].dataUrl}" alt="데이터"></div>`;
        }
        previewImgIdx++;
        html += `<div class="data-box"><table><tr>`;
        sec.dataPoints.headers.forEach(h => { html += `<th>${h}</th>`; });
        html += `</tr>`;
        if (sec.dataPoints.rows) {
          sec.dataPoints.rows.forEach(row => {
            html += `<tr>`;
            row.forEach(cell => { html += `<td>${cell}</td>`; });
            html += `</tr>`;
          });
        }
        html += `</table></div>`;
      }
      html += `</div>`;
    });
  }

  // Conclusion
  if (data.conclusion) {
    html += `<div class="conclusion">`;
    html += `<h3>정리</h3>`;
    if (data.conclusion.summary) html += `<p>${data.conclusion.summary}</p>`;
    if (data.conclusion.actionItems) {
      html += `<ul class="key-points">`;
      data.conclusion.actionItems.forEach((ai, i) => { html += `<li><strong>${i + 1}.</strong> ${ai}</li>`; });
      html += `</ul>`;
    }
    if (data.conclusion.encouragement) {
      html += `<p style="text-align:center; font-weight:700; color:var(--primary); margin-top:16px;">${data.conclusion.encouragement}</p>`;
    }
    html += `</div>`;
  }

  el.innerHTML = html;
}

function renderHtmlCode(html) {
  const el = document.getElementById('htmlCode');
  el.textContent = html;
}

// ─────────────────────────────────────────
// IMAGE GENERATION (Canvas)
// ─────────────────────────────────────────
function stripTags(text) {
  // HTML 태그 제거 (이미지 생성용)
  return text.replace(/<[^>]+>/g, '');
}

function wrapText(ctx, text, maxWidth) {
  const words = text.split('');
  let lines = [];
  let currentLine = '';
  for (const char of words) {
    const testLine = currentLine + char;
    if (ctx.measureText(testLine).width > maxWidth && currentLine) {
      lines.push(currentLine);
      currentLine = char;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) lines.push(currentLine);
  return lines;
}

async function waitForFont() {
  try {
    await document.fonts.load('800 56px "Nanum Myeongjo"');
    await document.fonts.load('700 36px "Nanum Myeongjo"');
    await document.fonts.load('400 28px "Nanum Myeongjo"');
  } catch (e) { /* proceed anyway */ }
}

function canvasToBlob(canvas) {
  return new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
}

// 2x DPI helper: creates a canvas at 2x resolution, returns {canvas, ctx} with ctx pre-scaled
const DPR = 2;
function createHiDpiCanvas(w, h) {
  const canvas = document.createElement('canvas');
  canvas.width = w * DPR;
  canvas.height = h * DPR;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(DPR, DPR);
  return { canvas, ctx, W: w, H: h };
}

// Multi-line text wrapper that returns lines + total height
function wrapTextLines(ctx, text, maxWidth, lineHeight) {
  const chars = text.split('');
  const lines = [];
  let cur = '';
  for (const ch of chars) {
    const test = cur + ch;
    if (ctx.measureText(test).width > maxWidth && cur) {
      lines.push(cur);
      cur = ch;
    } else {
      cur = test;
    }
  }
  if (cur) lines.push(cur);
  return { lines, totalHeight: lines.length * lineHeight };
}

// Title Header Image (860 x dynamic)
function generateTitleImage(title) {
  const W = 860;
  // Pre-measure to get dynamic height
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = 1; tmpCanvas.height = 1;
  const tmpCtx = tmpCanvas.getContext('2d');
  tmpCtx.font = '800 36px "Nanum Myeongjo", serif';
  const { lines } = wrapTextLines(tmpCtx, stripTags(title), W - 120, 52);
  const H = Math.max(200, 80 + lines.length * 52 + 60);

  const { canvas, ctx } = createHiDpiCanvas(W, H);

  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, W, H);
  grad.addColorStop(0, '#2d5a27');
  grad.addColorStop(1, '#1a3d15');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Decorative circles
  ctx.globalAlpha = 0.07;
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(W - 120, 60, 140, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(100, H - 40, 80, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  // Bottom accent bar
  ctx.fillStyle = '#fff8b2';
  ctx.fillRect(0, H - 8, W, 8);

  // Title text - big & centered
  ctx.font = '800 36px "Nanum Myeongjo", serif';
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const startY = H / 2 - (lines.length - 1) * 26;
  lines.forEach((line, i) => {
    ctx.fillText(line, W / 2, startY + i * 52);
  });

  return canvas;
}

// Section Header Image (860 x dynamic)
function generateSectionImage(sectionNumber, heading) {
  const W = 860;
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = 1; tmpCanvas.height = 1;
  const tmpCtx = tmpCanvas.getContext('2d');
  tmpCtx.font = '700 28px "Nanum Myeongjo", serif';
  const { lines } = wrapTextLines(tmpCtx, stripTags(heading), W - 160, 40);
  const H = Math.max(100, 40 + lines.length * 40 + 40);

  const { canvas, ctx } = createHiDpiCanvas(W, H);

  // Background
  ctx.fillStyle = '#f8faf7';
  ctx.fillRect(0, 0, W, H);

  // Left accent bar
  ctx.fillStyle = '#2d5a27';
  ctx.fillRect(0, 0, 8, H);

  // Number circle
  const circleR = 28;
  const circleX = 52;
  ctx.fillStyle = '#2d5a27';
  ctx.beginPath(); ctx.arc(circleX, H / 2, circleR, 0, Math.PI * 2); ctx.fill();
  ctx.font = '800 26px "Nanum Myeongjo", serif';
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(String(sectionNumber), circleX, H / 2);

  // Heading text
  ctx.font = '700 28px "Nanum Myeongjo", serif';
  ctx.fillStyle = '#1a1a1a';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  const textX = 100;
  const textStartY = H / 2 - (lines.length - 1) * 20;
  lines.forEach((line, i) => {
    ctx.fillText(line, textX, textStartY + i * 40);
  });

  // Bottom line
  ctx.strokeStyle = '#2d5a27';
  ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.moveTo(textX, H - 14); ctx.lineTo(W - 40, H - 14); ctx.stroke();

  return canvas;
}

// Key Points Image (860 x dynamic, multi-line support per point)
function generateKeyPointsImage(points) {
  const W = 860;
  const padding = 28;
  const headerH = 56;
  const textX = 60;
  const maxTextW = W - textX - 40;

  // Pre-measure each point for wrapping
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = 1; tmpCanvas.height = 1;
  const tmpCtx = tmpCanvas.getContext('2d');
  tmpCtx.font = '400 22px "Nanum Myeongjo", serif';
  const pointData = points.map(pt => {
    const { lines } = wrapTextLines(tmpCtx, stripTags(pt), maxTextW, 32);
    return { text: stripTags(pt), lines, blockH: Math.max(44, lines.length * 32 + 12) };
  });
  const totalPointsH = pointData.reduce((s, p) => s + p.blockH, 0);
  const H = headerH + padding + totalPointsH + padding;

  const { canvas, ctx } = createHiDpiCanvas(W, H);

  // Background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 1;
  ctx.strokeRect(0.5, 0.5, W - 1, H - 1);

  // Header bar
  ctx.fillStyle = '#2d5a27';
  ctx.fillRect(0, 0, W, headerH);
  ctx.font = '700 22px "Nanum Myeongjo", serif';
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('핵심 포인트', W / 2, headerH / 2);

  // Points
  let yOff = headerH + padding;
  pointData.forEach((pd, i) => {
    // Alternating bg
    if (i % 2 === 0) {
      ctx.fillStyle = '#f8faf7';
      ctx.fillRect(1, yOff - 4, W - 2, pd.blockH);
    }

    // Check icon
    ctx.font = '700 22px sans-serif';
    ctx.fillStyle = '#2d5a27';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText('\u2713', 24, yOff + 2);

    // Text lines
    ctx.font = '400 22px "Nanum Myeongjo", serif';
    ctx.fillStyle = '#333333';
    pd.lines.forEach((line, li) => {
      ctx.fillText(line, textX, yOff + li * 32 + 2);
    });

    yOff += pd.blockH;
  });

  return canvas;
}

// Data Infographic Image (860 x dynamic, text wrapping in cells)
function generateDataImage(dataPoints) {
  const W = 860;
  const titleH = dataPoints.title ? 56 : 0;
  const headerH = 52;
  const cols = dataPoints.headers.length;
  const colW = (W - 2) / cols;
  const cellPadX = 16;
  const maxCellTextW = colW - cellPadX * 2;

  // Pre-measure rows for wrapping
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = 1; tmpCanvas.height = 1;
  const tmpCtx = tmpCanvas.getContext('2d');
  tmpCtx.font = '400 20px "Nanum Myeongjo", serif';
  const rowData = (dataPoints.rows || []).map(row => {
    let maxLines = 1;
    const cellLines = row.map(cell => {
      const { lines } = wrapTextLines(tmpCtx, stripTags(cell), maxCellTextW, 28);
      if (lines.length > maxLines) maxLines = lines.length;
      return lines;
    });
    return { cellLines, rowH: Math.max(48, maxLines * 28 + 16) };
  });
  const totalRowsH = rowData.reduce((s, r) => s + r.rowH, 0);
  const H = titleH + headerH + totalRowsH + 16;

  const { canvas, ctx } = createHiDpiCanvas(W, H);

  // Background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 1;
  ctx.strokeRect(0.5, 0.5, W - 1, H - 1);

  let yOff = 0;

  // Title
  if (dataPoints.title) {
    ctx.fillStyle = '#fafbfc';
    ctx.fillRect(0, 0, W, titleH);
    ctx.font = '700 22px "Nanum Myeongjo", serif';
    ctx.fillStyle = '#2d5a27';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(dataPoints.title, W / 2, titleH / 2);
    yOff = titleH;
  }

  // Header
  ctx.fillStyle = '#2d5a27';
  ctx.fillRect(1, yOff, W - 2, headerH);
  ctx.font = '700 20px "Nanum Myeongjo", serif';
  ctx.fillStyle = '#ffffff';
  ctx.textBaseline = 'middle';
  dataPoints.headers.forEach((h, ci) => {
    ctx.textAlign = 'center';
    ctx.fillText(h, 1 + colW * ci + colW / 2, yOff + headerH / 2);
  });
  yOff += headerH;

  // Rows
  rowData.forEach((rd, ri) => {
    if (ri % 2 === 1) {
      ctx.fillStyle = '#f9f9f9';
      ctx.fillRect(1, yOff, W - 2, rd.rowH);
    }
    ctx.fillStyle = '#333333';
    ctx.font = '400 20px "Nanum Myeongjo", serif';
    rd.cellLines.forEach((lines, ci) => {
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const cellCenterX = 1 + colW * ci + colW / 2;
      const blockH = lines.length * 28;
      const startY = yOff + (rd.rowH - blockH) / 2 + 14;
      lines.forEach((line, li) => {
        ctx.fillText(line, cellCenterX, startY + li * 28);
      });
    });
    // Row separator
    ctx.strokeStyle = '#eeeeee';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(1, yOff + rd.rowH); ctx.lineTo(W - 1, yOff + rd.rowH); ctx.stroke();
    yOff += rd.rowH;
  });

  return canvas;
}

// Card-News Representative Image (1080x1080, full green, title only, 2x DPI)
function generateCardNewsImage(title) {
  const S = 1080;
  const { canvas, ctx, W, H } = createHiDpiCanvas(S, S);

  // Full green background
  const grad = ctx.createLinearGradient(0, 0, W, H);
  grad.addColorStop(0, '#2d5a27');
  grad.addColorStop(1, '#1a3d15');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Subtle circle decorations
  ctx.globalAlpha = 0.05;
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(W - 120, 140, 220, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(120, H - 140, 180, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  // Yellow accent line top
  ctx.fillStyle = '#fff8b2';
  ctx.fillRect(W / 2 - 60, 80, 120, 6);

  // Title - HUGE, 2~3 lines, dead center
  const titleText = stripTags(title);
  let fontSize = 100;
  let titleLines, lineH;
  while (fontSize >= 52) {
    ctx.font = `800 ${fontSize}px "Nanum Myeongjo", serif`;
    const result = wrapTextLines(ctx, titleText, W - 160, Math.round(fontSize * 1.4));
    if (result.lines.length >= 2 && result.lines.length <= 3) {
      titleLines = result.lines;
      lineH = Math.round(fontSize * 1.4);
      break;
    }
    if (result.lines.length === 1 && fontSize > 52) {
      // Force 2 lines by shrinking maxWidth
      const narrow = wrapTextLines(ctx, titleText, W - 360, Math.round(fontSize * 1.4));
      if (narrow.lines.length === 2) {
        titleLines = narrow.lines;
        lineH = Math.round(fontSize * 1.4);
        break;
      }
    }
    fontSize -= 4;
  }
  if (!titleLines) {
    ctx.font = '800 52px "Nanum Myeongjo", serif';
    const result = wrapTextLines(ctx, titleText, W - 160, 73);
    titleLines = result.lines.slice(0, 3);
    lineH = 73;
    fontSize = 52;
  }

  ctx.font = `800 ${fontSize}px "Nanum Myeongjo", serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#ffffff';
  const titleBlockH = titleLines.length * lineH;
  const titleStartY = H / 2 - titleBlockH / 2 + lineH / 2;
  titleLines.forEach((line, i) => {
    ctx.fillText(line, W / 2, titleStartY + i * lineH);
  });

  // Yellow accent line bottom
  ctx.fillStyle = '#fff8b2';
  ctx.fillRect(W / 2 - 60, H - 80, 120, 6);

  return canvas;
}

async function generateAllImages(data) {
  await waitForFont();
  generatedImages = [];
  let imgIdx = 0;

  // 0. Card-news representative image (블로그 대표이미지)
  const cardCanvas = generateCardNewsImage(data.title || '블로그 글');
  const cardBlob = await canvasToBlob(cardCanvas);
  generatedImages.push({ label: `${++imgIdx}. 대표이미지 (카드뉴스)`, blob: cardBlob, dataUrl: cardCanvas.toDataURL(), isRepresentative: true });

  // 1. Title image
  const titleCanvas = generateTitleImage(data.title || '블로그 글');
  const titleBlob = await canvasToBlob(titleCanvas);
  generatedImages.push({ label: `${++imgIdx}. 타이틀 헤더`, blob: titleBlob, dataUrl: titleCanvas.toDataURL() });

  // 2. Section images
  if (data.sections) {
    for (let i = 0; i < data.sections.length; i++) {
      const sec = data.sections[i];

      // Section header
      const secCanvas = generateSectionImage(i + 1, sec.heading);
      const secBlob = await canvasToBlob(secCanvas);
      generatedImages.push({ label: `${++imgIdx}. 섹션: ${sec.heading}`, blob: secBlob, dataUrl: secCanvas.toDataURL() });

      // Key points
      if (sec.keyPoints && sec.keyPoints.length) {
        const kpCanvas = generateKeyPointsImage(sec.keyPoints);
        const kpBlob = await canvasToBlob(kpCanvas);
        generatedImages.push({ label: `${++imgIdx}. 핵심 포인트`, blob: kpBlob, dataUrl: kpCanvas.toDataURL() });
      }

      // Data
      if (sec.dataPoints && sec.dataPoints.headers) {
        const dpCanvas = generateDataImage(sec.dataPoints);
        const dpBlob = await canvasToBlob(dpCanvas);
        generatedImages.push({ label: `${++imgIdx}. 데이터: ${sec.dataPoints.title || '표'}`, blob: dpBlob, dataUrl: dpCanvas.toDataURL() });
      }
    }
  }
}

// ─────────────────────────────────────────
// IMAGES TAB
// ─────────────────────────────────────────
function renderImagesTab() {
  const container = document.getElementById('imagesContainer');
  if (!generatedImages.length) {
    container.innerHTML = '<div style="text-align:center; padding:40px; color:var(--text-light);">이미지가 없습니다.</div>';
    return;
  }
  let html = `<button class="download-all-btn" onclick="downloadAllImages()">&#128230; 모든 이미지 ZIP 다운로드</button>`;
  html += `<div class="images-grid">`;
  generatedImages.forEach((img, i) => {
    const isRep = img.isRepresentative;
    html += `<div class="image-card" style="${isRep ? 'border: 2px solid var(--primary); background: var(--primary-light);' : ''}">`;
    html += `<div class="image-label">${img.label}${isRep ? ' <span style="font-size:11px; background:var(--primary); color:#fff; padding:2px 8px; border-radius:10px; margin-left:6px;">블로그 대표이미지용</span>' : ''}</div>`;
    html += `<img src="${img.dataUrl}" alt="${img.label}" style="${isRep ? 'max-width:400px;' : ''}">`;
    html += `<div class="image-actions">`;
    html += `<button onclick="downloadSingleImage(${i})">다운로드</button>`;
    html += `</div></div>`;
  });
  html += `</div>`;
  container.innerHTML = html;
}

function downloadSingleImage(idx) {
  const img = generatedImages[idx];
  const a = document.createElement('a');
  a.href = img.dataUrl;
  a.download = `blog-image-${idx + 1}.png`;
  a.click();
}

async function downloadAllImages() {
  if (!generatedImages.length) { showToast('생성된 이미지가 없습니다.'); return; }
  const zip = new JSZip();
  generatedImages.forEach((img, i) => {
    zip.file(`blog-image-${i + 1}.png`, img.blob);
  });
  const content = await zip.generateAsync({ type: 'blob' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(content);
  a.download = 'blog-images.zip';
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('이미지 ZIP 다운로드 시작!');
}

// ─────────────────────────────────────────
// SECTIONS TAB (Section-by-Section Copy)
// ─────────────────────────────────────────
function renderSectionsTab(data) {
  sectionParts = [];
  const container = document.getElementById('sectionsContainer');
  if (!data) { container.innerHTML = '<div style="text-align:center; padding:40px; color:var(--text-light);">원고를 먼저 생성해주세요.</div>'; return; }

  let imgIdx = 0;

  // Card-news representative image
  sectionParts.push({ type: 'image', label: '대표이미지 (카드뉴스)', imgIdx: imgIdx++ });

  // Title image
  sectionParts.push({ type: 'image', label: '타이틀 헤더 이미지', imgIdx: imgIdx++ });

  // Hook
  sectionParts.push({ type: 'text', label: '도입부', html: `<p>${data.hook}</p>` });

  // Context
  if (data.context) {
    sectionParts.push({ type: 'text', label: '맥락', html: `<p>${data.context}</p>` });
  }

  // TOC
  if (data.toc && data.toc.length) {
    let tocHtml = '';
    data.toc.forEach((item, i) => { tocHtml += `<p><b>${i + 1}. ${item}</b></p>`; });
    sectionParts.push({ type: 'text', label: '목차', html: tocHtml });
  }

  // Sections
  if (data.sections) {
    data.sections.forEach((sec, idx) => {
      // Section image
      sectionParts.push({ type: 'image', label: `섹션 ${idx + 1} 이미지`, imgIdx: imgIdx++ });

      // Section heading + paragraphs (clean HTML)
      let secHtml = `<p><b>${sec.heading}</b></p>`;
      if (sec.paragraphs) {
        sec.paragraphs.forEach(p => { secHtml += `<p>${p}</p>`; });
      }
      sectionParts.push({ type: 'text', label: `섹션 ${idx + 1}: ${sec.heading}`, html: secHtml });

      // Key points
      if (sec.keyPoints && sec.keyPoints.length) {
        sectionParts.push({ type: 'image', label: `핵심 포인트 이미지`, imgIdx: imgIdx++ });
        let kpHtml = '';
        sec.keyPoints.forEach(kp => { kpHtml += `<p>\u2713 ${kp}</p>`; });
        sectionParts.push({ type: 'text', label: `핵심 포인트 텍스트`, html: kpHtml });
      }

      // Data points
      if (sec.dataPoints && sec.dataPoints.headers) {
        sectionParts.push({ type: 'image', label: `데이터 이미지`, imgIdx: imgIdx++ });
      }
    });
  }

  // Conclusion
  if (data.conclusion) {
    let conHtml = '';
    if (data.conclusion.summary) conHtml += `<p>${data.conclusion.summary}</p>`;
    if (data.conclusion.actionItems) {
      data.conclusion.actionItems.forEach((ai, i) => { conHtml += `<p>${i + 1}. ${ai}</p>`; });
    }
    if (data.conclusion.encouragement) {
      conHtml += `<p><b>${data.conclusion.encouragement}</b></p>`;
    }
    sectionParts.push({ type: 'text', label: '결론', html: conHtml });
  }

  // Render
  let html = `<div class="section-copy-panel">`;
  html += `<div style="font-size:13px; color:var(--text-light); margin-bottom:16px; padding:12px; background:#f8f9fa; border-radius:8px;">
    텍스트는 "복사" 버튼으로 서식 복사 후 네이버 에디터에 붙여넣기하세요.<br>
    이미지는 "다운로드" 후 에디터에서 직접 삽입하세요.
  </div>`;

  sectionParts.forEach((part, i) => {
    html += `<div class="section-copy-item">`;
    html += `<span class="type-badge">${part.type === 'image' ? '이미지' : '텍스트'}</span>`;
    html += `<span class="label">${part.label}</span>`;
    if (part.type === 'text') {
      html += `<button id="secCopyBtn${i}" onclick="copySectionPart(${i})">복사</button>`;
    } else {
      html += `<button onclick="downloadSingleImage(${part.imgIdx})">다운로드</button>`;
    }
    html += `</div>`;
  });
  html += `</div>`;
  container.innerHTML = html;
}

function copySectionPart(idx) {
  const part = sectionParts[idx];
  if (!part || part.type !== 'text') return;
  copyHtmlToClipboard(part.html);
  const btn = document.getElementById('secCopyBtn' + idx);
  if (btn) { btn.textContent = '복사됨!'; btn.classList.add('copied'); setTimeout(() => { btn.textContent = '복사'; btn.classList.remove('copied'); }, 1500); }
  showToast('클립보드에 복사되었습니다.');
}

// ─────────────────────────────────────────
// CLIPBOARD
// ─────────────────────────────────────────
function copyHtmlToClipboard(html) {
  const blob = new Blob([html], { type: 'text/html' });
  const plainText = html.replace(/<[^>]+>/g, '').replace(/&nbsp;/g, ' ').replace(/&#\d+;/g, '');
  const textBlob = new Blob([plainText], { type: 'text/plain' });
  navigator.clipboard.write([
    new ClipboardItem({
      'text/html': blob,
      'text/plain': textBlob
    })
  ]).catch(err => {
    // Fallback: copy plain text
    navigator.clipboard.writeText(plainText);
    console.warn('Rich copy failed, used plain text fallback:', err);
  });
}

function copyRichText() {
  if (!generatedHtml) { showToast('먼저 원고를 생성해주세요.'); return; }
  copyHtmlToClipboard(generatedHtml);
  showToast('서식 포함 텍스트가 복사되었습니다!');
}

function copyHtmlCode() {
  if (!generatedHtml) { showToast('먼저 원고를 생성해주세요.'); return; }
  navigator.clipboard.writeText(generatedHtml);
  showToast('HTML 코드가 복사되었습니다!');
}

// ─────────────────────────────────────────
// MODAL CLOSE ON BACKDROP
// ─────────────────────────────────────────
document.getElementById('settingsModal').addEventListener('click', function(e) {
  if (e.target === this) closeSettings();
});

// ─────────────────────────────────────────
// KEYBOARD SHORTCUT
// ─────────────────────────────────────────
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') closeSettings();
  if (e.ctrlKey && e.key === 'Enter') generateArticle();
});
</script>
</body>
</html>
